# Respons√°vel por: extrair contatos completos - INSERIR APENAS NOVOS (SEM COMPARA√á√ÉO)

from datetime import datetime
import time
import requests
from core.base_extractor import BaseExtractor
from models.contact_raw import ContatoRaw
from config.settings import endpoints, headers
from config.database import Session
from sqlalchemy import text

# =============================================================
# 1. CRIANDO A CLASSE PARA EXTRA√á√ÉO DE CLIENTES + ENDERE√áOS
# =============================================================

class ContatosCompletoExtractor(BaseExtractor):
    """
    Extrator otimizado que INSERE APENAS NOVOS contatos
    SEM compara√ß√£o de dados existentes
    MUDAN√áA: N√£o usa salvar_dados_postgres_bulk() igual os contatos e vendas.
    """
    
    def __init__(self):
        super().__init__(endpoints['contatos'], ContatoRaw)
    
    def executar_extracao_completa(self):
        """
        Processo otimizado: inserir apenas novos (SEM COMPARA√á√ÉO)
        """
        try:
            print("üöÄ EXTRA√á√ÉO: CONTATOS COMPLETOS")
            print("‚ö° Estrat√©gia: Inserir apenas novos (SEM compara√ß√£o de JSON)")
            print("=" * 60)
            inicio_total = datetime.now()
            
            # ETAPA 1: Extrair lista b√°sica de contatos
            print("\n1Ô∏è‚É£ EXTRAINDO LISTA B√ÅSICA DE CONTATOS...")
            inicio_lista = datetime.now()
            
            lista_contatos = self.extract_dados_bling_paginado(
                limite_por_pagina=100,
                delay_entre_requests=0.35,
                max_paginas=1000,
                max_tentativas=3
            )
            
            fim_lista = datetime.now()
            tempo_lista = fim_lista - inicio_lista
            
            if not lista_contatos:
                print("‚ùå Nenhum contato extra√≠do da API")
                return
            
            print(f"‚úÖ {len(lista_contatos)} contatos extra√≠dos em {tempo_lista}")
            
            # ETAPA 2: Identificar apenas novos (1 query √∫nica e r√°pida)
            print(f"\n2Ô∏è‚É£ IDENTIFICANDO CONTATOS NOVOS...")
            inicio_filtro = datetime.now()
            
            contatos_novos = self._filtrar_apenas_novos(lista_contatos)
            
            fim_filtro = datetime.now()
            
            if not contatos_novos:
                print(f"‚úÖ Nenhum contato novo encontrado. Base j√° atualizada!")
                print(f"‚è±Ô∏è  Tempo de verifica√ß√£o: {fim_filtro - inicio_filtro}")
                return
            
            print(f"‚úÖ {len(contatos_novos)} contatos novos identificados em {fim_filtro - inicio_filtro}")
            
            # ETAPA 3: Buscar detalhes apenas dos novos
            print(f"\n3Ô∏è‚É£ BUSCANDO DETALHES DOS NOVOS CONTATOS...")
            inicio_detalhes = datetime.now()
            
            contatos_completos = self._buscar_detalhes_otimizado(contatos_novos)
            
            fim_detalhes = datetime.now()
            tempo_detalhes = fim_detalhes - inicio_detalhes
            
            print(f"‚úÖ Detalhes coletados em {tempo_detalhes}")
            
            # ETAPA 4: Salvar apenas novos (SEM COMPARA√á√ÉO - DIRETO)
            print(f"\n4Ô∏è‚É£ SALVANDO NOVOS CONTATOS (INSERT DIRETO)...")
            inicio_salvamento = datetime.now()
            
            # ‚ö° FUN√á√ÉO OTIMIZADA - N√ÉO USA salvar_dados_postgres_bulk()
            stats = self._salvar_novos_direto(contatos_completos)
            
            fim_salvamento = datetime.now()
            fim_total = datetime.now()
            
            # RELAT√ìRIO FINAL
            print(f"\nüéâ EXTRA√á√ÉO CONCLU√çDA COM SUCESSO!")
            print(f"=" * 60)
            print(f"\n‚è±Ô∏è  TEMPOS:")
            print(f"   ‚Ä¢ Extra√ß√£o da API: {tempo_lista}")
            print(f"   ‚Ä¢ Filtro de novos: {fim_filtro - inicio_filtro}")
            print(f"   ‚Ä¢ Busca detalhes: {tempo_detalhes}")
            print(f"   ‚Ä¢ Salvamento: {fim_salvamento - inicio_salvamento}")
            print(f"   ‚Ä¢ TOTAL: {fim_total - inicio_total}")
            
            print(f"\nüìä ESTAT√çSTICAS GERAIS:")
            print(f"   ‚Ä¢ Total de contatos na API: {len(lista_contatos)}")
            print(f"   ‚Ä¢ Contatos j√° existentes no banco: {len(lista_contatos) - len(contatos_novos)}")
            print(f"   ‚Ä¢ Contatos novos encontrados: {len(contatos_novos)}")
            
            print(f"\nüíæ OPERA√á√ïES NO BANCO:")
            print(f"   ‚Ä¢ Inseridos com sucesso: {stats['inseridos']}")
            print(f"   ‚Ä¢ Erros durante inser√ß√£o: {stats['erros']}")
            
            print(f"\nüìà RESUMO DO BANCO:")
            # Consulta total no banco ap√≥s inser√ß√£o
            total_no_banco = self._contar_total_no_banco()
            print(f"   ‚Ä¢ Total de contatos no banco agora: {total_no_banco}")
            
            # Estat√≠sticas de endere√ßos
            self._calcular_estatisticas_enderecos(contatos_completos, len(contatos_novos))
            
            # Resumo de economia
            economia_operacoes = len(lista_contatos) - len(contatos_novos)
            if economia_operacoes > 0:
                print(f"\n‚ö° ECONOMIA:")
                print(f"   ‚Ä¢ {economia_operacoes} inser√ß√µes duplicadas evitadas")
            
            print(f"\n‚ú® Estrat√©gia otimizada executada com sucesso!")
            
        except Exception as e:
            print(f"\n‚ùå ERRO CR√çTICO: {e}")
            raise
    
    def _filtrar_apenas_novos(self, lista_contatos):
        """
        Filtra apenas contatos que N√ÉO existem no banco
        OTIMIZA√á√ÉO: Uma √∫nica query SQL para verificar todos os IDs de uma vez
        
        Args:
            lista_contatos: Lista de contatos da API
            
        Returns:
            list: Apenas contatos que n√£o existem no banco
        """
        session = Session()
        
        try:
            # Extrai todos os IDs da API
            ids_api = [c['id'] for c in lista_contatos]
            
            if not ids_api:
                return []
            
            # Query √∫nica para buscar todos os IDs que j√° existem
            # Muito mais r√°pido que 1000 queries individuais
            query = text("""
                SELECT bling_id 
                FROM raw.contatos_raw 
                WHERE bling_id = ANY(:ids)
            """)
            
            resultado = session.execute(query, {"ids": ids_api})
            ids_existentes = set(row.bling_id for row in resultado)
            
            # Filtra apenas os que N√ÉO existem
            contatos_novos = [c for c in lista_contatos if c['id'] not in ids_existentes]
            
            print(f"   üìä {len(ids_existentes)} j√° existem no banco")
            print(f"   üÜï {len(contatos_novos)} s√£o novos")
            
            return contatos_novos
            
        except Exception as e:
            print(f"‚ùå Erro ao filtrar contatos: {e}")
            raise
        finally:
            session.close()
    
    def _salvar_novos_direto(self, contatos_completos):
        """
        NOVA FUN√á√ÉO OTIMIZADA: Salva direto sem compara√ß√£o
        
        - Sem SELECT de registros existentes
        - Sem compara√ß√£o de JSON  
        - Apenas INSERT direto
        - Commits em lote para performance
        
        Args:
            contatos_completos: Lista de contatos processados
            
        Returns:
            dict: Estat√≠sticas de inser√ß√£o
        """
        if not contatos_completos:
            return {'inseridos': 0, 'erros': 0}
        
        session = Session()
        stats = {'inseridos': 0, 'erros': 0}
        
        try:
            print(f"   üíæ Preparando {len(contatos_completos)} registros para inser√ß√£o...")
            
            for i, contato in enumerate(contatos_completos):
                try:
                    # Cria objeto diretamente (sem verifica√ß√µes)
                    novo_registro = ContatoRaw(
                        bling_id=contato['id'],
                        dados_json=contato,
                        data_ingestao=datetime.now(),
                        status_processamento='pendente'
                    )
                    
                    session.add(novo_registro)
                    stats['inseridos'] += 1
                    
                    # Commit em lotes de 100 para performance
                    if (i + 1) % 100 == 0:
                        session.commit()
                        print(f"   ‚úÖ {i + 1}/{len(contatos_completos)} registros inseridos...")
                    
                except Exception as e:
                    session.rollback()
                    stats['erros'] += 1
                    erro_msg = str(e)
                    
                    # Log apenas se n√£o for duplicata (que seria estranho aqui)
                    if "duplicate key" not in erro_msg and "already exists" not in erro_msg:
                        print(f"   ‚ùå Erro no contato {contato.get('id')}: {erro_msg[:100]}")
            
            # Commit final para registros restantes
            session.commit()
            print(f"   ‚úÖ Commit final realizado")
            
        except Exception as e:
            session.rollback()
            print(f"‚ùå Erro cr√≠tico no salvamento: {e}")
            raise
        finally:
            session.close()
        
        return stats
    
    def _buscar_detalhes_otimizado(self, lista_contatos):
        """
        Busca detalhes completos dos contatos (incluindo endere√ßos)
        com delay otimizado entre requisi√ß√µes
        
        Args:
            lista_contatos: Lista de contatos b√°sicos
            
        Returns:
            list: Contatos com detalhes completos e endere√ßos estruturados
        """
        contatos_completos = []
        total = len(lista_contatos)
        
        print(f"   üì° Buscando detalhes de {total} contatos...")
        
        for i, contato in enumerate(lista_contatos):
            # Progresso a cada 50 contatos
            if (i + 1) % 50 == 0:
                print(f"   Processando {i + 1}/{total}...")
            
            # Busca detalhes do contato
            detalhes = self._buscar_detalhes_contato(contato['id'])
            
            if detalhes:
                # Processa e estrutura o endere√ßo
                processado = self._processar_contato_detalhado(detalhes)
                contatos_completos.append(processado)
            else:
                # Se n√£o conseguir detalhes, usa dados b√°sicos
                contatos_completos.append(contato)
            
            # Delay pequeno para n√£o estourar rate limit
            time.sleep(0.05)
        
        return contatos_completos
    
    def _buscar_detalhes_contato(self, contato_id):
        """
        Busca detalhes completos de um contato espec√≠fico
        
        Args:
            contato_id: ID do contato no Bling
            
        Returns:
            dict: Dados completos do contato ou None se falhar
        """
        try:
            url = f"{endpoints['contatos']}/{contato_id}"
            response = requests.get(url, headers=headers, timeout=30)
            
            if response.status_code == 200:
                return response.json().get('data', {})
            else:
                return None
                
        except Exception:
            return None
    
    def _processar_contato_detalhado(self, contato_detalhado):
        """
        Processa contato adicionando estrutura de endere√ßo formatada
        
        Args:
            contato_detalhado: Dados completos do contato da API
            
        Returns:
            dict: Contato com endere√ßo estruturado
        """
        endereco_geral = contato_detalhado.get("endereco", {}).get("geral", {})
        contato_processado = contato_detalhado.copy()
        
        if endereco_geral:
            contato_processado['endereco_estruturado'] = {
                'tem_endereco': True,
                'endereco_completo_formatado': self._formatar_endereco_contato(endereco_geral),
                'endereco_detalhado': {
                    'logradouro': endereco_geral.get('endereco'),
                    'numero': endereco_geral.get('numero'),
                    'complemento': endereco_geral.get('complemento'),
                    'bairro': endereco_geral.get('bairro'),
                    'cidade': endereco_geral.get('municipio'),
                    'estado': endereco_geral.get('uf'),
                    'cep': endereco_geral.get('cep'),
                    'pais': endereco_geral.get('pais', 'Brasil')
                },
                'data_processamento': datetime.now().isoformat()
            }
        else:
            contato_processado['endereco_estruturado'] = {
                'tem_endereco': False,
                'endereco_completo_formatado': None,
                'endereco_detalhado': None,
                'data_processamento': datetime.now().isoformat()
            }
        
        return contato_processado
    
    def _formatar_endereco_contato(self, endereco_geral):
        """
        Formata endere√ßo em string leg√≠vel
        
        Args:
            endereco_geral: Dicion√°rio com dados do endere√ßo
            
        Returns:
            str: Endere√ßo formatado ou None se vazio
        """
        partes = [
            endereco_geral.get('endereco', ''),
            endereco_geral.get('numero', ''),
            endereco_geral.get('complemento', ''),
            endereco_geral.get('bairro', ''),
            endereco_geral.get('municipio', ''),
            endereco_geral.get('uf', ''),
            endereco_geral.get('cep', '')
        ]
        
        partes_validas = [p.strip() for p in partes if p and p.strip()]
        return ', '.join(partes_validas) if partes_validas else None
    
    def _calcular_estatisticas_enderecos(self, contatos_completos, total_contatos):
        """
        Calcula e exibe estat√≠sticas sobre endere√ßos
        
        Args:
            contatos_completos: Lista de contatos processados
            total_contatos: Total de contatos
        """
        contatos_com_endereco = sum(
            1 for c in contatos_completos
            if c.get('endereco_estruturado', {}).get('tem_endereco', False)
        )
        
        print(f"\nüè† ESTAT√çSTICAS DE ENDERE√áOS:")
        print(f"   ‚Ä¢ Com endere√ßos completos: {contatos_com_endereco}/{total_contatos}")
        
        if total_contatos > 0:
            taxa = (contatos_com_endereco / total_contatos) * 100
            print(f"   ‚Ä¢ Taxa de cobertura: {taxa:.1f}%")
            
            if taxa < 50:
                print(f"   ‚ö†Ô∏è  Aten√ß√£o: Mais de 50% dos contatos sem endere√ßo")
    
    def _contar_total_no_banco(self):
        """
        Conta o total de contatos no banco ap√≥s inser√ß√£o
        """
        session = Session()
        try:
            query = text("SELECT COUNT(*) FROM raw.contatos_raw")
            resultado = session.execute(query)
            total = resultado.scalar()
            return total
        finally:
            session.close()